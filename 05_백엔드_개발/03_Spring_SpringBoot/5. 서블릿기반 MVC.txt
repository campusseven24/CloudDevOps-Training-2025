1. JSP의 한계 
    1) 비즈니스 로직과 View가 섞임 (유지보수 어려움)
    2) Java 코드와 HTML이 혼재 (가독성 저하)
    3) 디자이너와 협업 어려움 

2. 권장 사항 
    1) MVC 패턴 사용 (Model-View-Controller)
    2) JSP는 View 역할만 담당
    3) 비즈니스 로직은 서블릿이나 Service 클래스에서 처리 
    4) JSP는 JSTL, EL로 Java 코드 최소화  

3. MVC 패턴 적용 
    1) 서블릿은 컨트롤러로 사용, JSP는 뷰로 사용해서 MVC 패턴 적용하기 
    2) 회원 등록 
        - 회원 등록 폼 (컨트롤러)      

4. Mode View Controller
    1) 컨트롤러 
        - HTTP 요청을 받아서 파라미터를 검증하고, 비즈니스 로직을 실행함          
        - 뷰에 전달한 결과 데이터를 조회해서 모델에 담음
    2) 모델 
        - 뷰에 출력할 데이터를 담아둠 
    3) 뷰 
        - 모델에 담겨있는 데이터를 사용해서 화면을 그리는 일에 집중함 

5. 시나리오 
    1) 회원가입
        - 클라이언트 (브라우저)
            - /servlet-mvc/members/new-form  GET 요청 
        - MvcMemberFormServlet (Controller)
            - service() 메소드 실행 
            - Model 데이터 없음, 바로 forward() 준비
        - RequestDispatcher
            - "WEB-INF/views/new-form.jsp" 서버 내부 전달 
            - dispatcher.forward()
                - 다른 서블릿이나 JSP로 이동할 수 있는 기능임 
                - 서버 내부에서 다시 호출이 발생함 
                - /WEB-INF
                    - 이 경로안에 JSP가 있으면 외부에서 직접 JSP를 호출할 수 없음.
                    - 항상 컨트롤러를 통해서 JSP를 호출함         
        - new-form.jsp (View) 
            - HTML 폼 생성 
            - action 
                - 절대 경로(/로 시작)가 아니라 
                  상대 경로(/로 시작 X)임 
                  - 상대경로를 사용하면 폼 전송시 현재 URL이 속한 계층 경로 + save가 호출됨.
                - 현재 계층 경로 : /servlet-mvc/members/
                  - 결과:  /servlet-mvc/members/save   

        - HTTP Response 
            - 클라이언트에게 폼 화면 전송 (URL 변경 없음)           

        - 회원 등록 폼 
            - redirect vs forward
                - 리다이렉트 
                    - 실제 클라이언트(웹 브라우저)에 응답이 나갔다가,
                      클라이언트가 redirect 경로로 다시 요청함.
                    - 클라이언트가 인지할 수 있고, URL 경로도 실제로 변경됨.
                - 포워드 
                    - 서버 내부에서 일어나는 호출 
                    - 클라이언트가 전혀 인지하지 못함.

    2) 회원 저장 처리 
        - 클라이언트 (브라우저)
            - 폼 데이터 전송
                - POST /save 
                 - username=홍길동
                   age=25

        - MvcMemberSaveServlet (Controller) 
            - getParameter("username") 
              getParameter("age")    
            - new Member(홍길동, 25)
            - repository.save(member)    
            - setAttribute("member", member);  
            - forward()  

        - MemberRepository (Model)
            - member.setId(++seq);
            - store.put(id, member)
            - return member 

        - RequestDispatcher 

        - save-result.jsp (View)
            - EL로 데이터 읽기 
            - HTML 생성 

        - HTTP Response
            - 저장 성공 화면 
            - /save 유지                    

    3) 회원 목록 조회 
        - 클라이언트 (브라우저)
            - GET 요청
            - /servlet-mvc/members

        - MvcMemberListServlet (Controller)           
            - service() 시작 
            - repository.findAll()
            - List<Member> members 
            - setAttribute("members", list)
            - forward()

        - MemberRepository (Model)
            - store.values()
            - return Arraylist                

        - RequestDispatcher 

        - members.jsp (View)
            - JSTL 
                - c:forEach
            - EL 

        - HTTP Response 
            - HTML 회원목록                                 

6. MVC 패턴 - 한계
    1) 구조와 역할 명확하게 구분됨
    2) 코드가 깔금하고 직관적임 
    3) 컨트롤러는 중복 코드가 있고, 코드의 최적화 필요함 
        - 포워드 중복 
            - View로 이동하는 코드가 항상 중복 호출되어야 함 

    4) 프런트 컨트롤러(Front Controller) 패턴 도입하면 위 문제 해결가능
        - 입구를 하나로 둠.
                              