1. 프런트 컨트롤러 패턴 소개 
    1) 특징
        - 프런트 컨트롤러 서블릿 하나로 클라이언트의 요청을 받음 
        - 프런트 컨트롤러가 요청에 맞는 컨트롤러를 찾아서 호출 
        - 공통 처리 가능 
        - 프런트 컨트롤러를 제외한 나머지 컨트롤러는 서블릿을
          사용하지 않아도 됨 

    2) Spring Web MVC와 프런트 컨트롤러 
        - Spring Web MVC의 핵심도 바로 FrontController
        - Spring Web MVC의 DispatcherServlet이 
          FrontController 패턴으로 구현되어 있음 

2. 프런트 컨트롤러 도입 (s1)
    1) 회원 등록 컨트롤러      

3. View 분리 (s2)
  1) 모든 컨트롤러에서 뷰로 이동하는 부분에 중복이 있고, 깔끔하지 않음
    - 각 Controller가 직접 RequestDispatcher.forward() 호출
    - View 경로가 Controller에 하드코딩 
  2) 깔끔하게 분리하기 위해 별도로 뷰를 처리하는 객체를 생성함 
    - View 랜더링 로직을 Controller로부터 분리 

  3) 각 컨트롤러는 복잡한 dispatcher.forward()를 직접 생성해서 
     호출하지 않아도 됨.
     - MyView 객체를 생성하고 거기에 뷰 이름만 넣고 반환하면 됨.  

  4) 아직 남은 이슈 
    - Controller가 여전히 HttpServletRequest/HttpServletResponse 의존
    - request.setAttribute()로 Model에 저장 
    - Servlet 기술에 종속적임
      - s3에서 Model 분리, ViewResolver 도입     

4. Model 추가 (s3)
  1) 서블릿 종속성 제거 
    - Map<String,String> paramMap 사용
    - Controller는 순수 Java 코드 
    - 단위 테스트 매우 간단 

  2) Model 분리 (ModelView)
    - 순수 Java Map으로 Model 관리 
    - Spring ModelAndView와 동일

  3) ViewResolver 도입 
    - 논리적 View 이름만 사용
    - "new-form" => 전체 경로 변환 
    - View 경로 변경시 한 곳만 수정 
    - Spring ViewResolver와 동일 

  4) 책임의 명확한 분리 
    - FrontController
      - Servlet 기술 처리 (Request => Map 변환)
      - ViewResolver 실행
      - Model => request attribute도 변환   

    - Controller  
      - 비즈니스 로직만 집중 
      - Servelt API 모름 
      - POJO (Plain Old Java Object)

5. 단순한 컨트롤러 (s4)






